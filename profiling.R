proftable <- function(file, lines = "show") {
  #' An alternative to summaryRprof
  #' 
  #' proftools} parses a profiling file and prints an easy-to-understand
  #' table showing the most time-intensive function calls. 
  #' 
  #' Line numbers are #' included if \code{Rprof()} was run with 
  #' \code{line.numbering=TRUE}. If it was run with \code{memory.profiling=TRUE},
  #' this function will probably break.
  #' 
  #' Below the table are printed any files identified if line numbering is true,
  #' the total time recorded by \code{Rprof()}, and the "parent call".  The
  #' parent call consists of the parent call stack of all the call stacks in the\
                                                                                #' table. Note that this is the parent call stack of only the printed lines,
                                                                                #' not of all stacks recorded by \code{Rprof()}. This makes the table easier to. 
                                                                                #' 
                                                                                #' @export
                                                                                #' @param file A profiling file generated by \code{Rprof()}
                                                                                #' @param lines The number of lines (call stacks) you want returned. Lines are
                                                                                #' printed from most time-intensive to least.  Only a few 
  profdata <- readLines(file)
  interval <- as.numeric(strsplit(profdata[1L], "=")[[1L]][2L]) / 1e+06
  filelines <- grep("#File", profdata)
  files <- profdata[filelines]
  if (length(filelines) > 0)
    profdata <- profdata[-1:-filelines]
  total.time <- interval * length(profdata)
  ncalls <- length(profdata)
  profdata <- gsub("\\\"| $", "", profdata)
  calls <- lapply(profdata, function(x) rev(unlist(strsplit(x, " "))))
  calls.len <- range(sapply(calls, length))
  parent.call <- unlist(lapply(seq(calls.len[1]), function(i) Reduce(intersect, lapply(calls,"[[", i))))
  calls <- lapply(calls, function(x) setdiff(x, parent.call))
  stacktable <- as.data.frame(table(sapply(calls, function(x) paste(x, collapse = " > "))) / ncalls * 100, stringsAsFactors = FALSE)
  stacktable <- stacktable[order(stacktable$Freq[], decreasing = TRUE), 2:1]
  colnames(stacktable) <- c("PctTime", "Call")
  stacktable <- head(stacktable, lines)
  if (length(parent.call) > 0) {
    parent.call <- paste(parent.call, collapse = " > ")
  } else {
    parent.call <- "None"
  }
  frac <- sum(stacktable$PctTime)
  attr(stacktable, "total.time") <- total.time
  attr(stacktable, "parent.call") <- parent.call
  attr(stacktable, "files") <- files
  attr(stacktable, "total.pct.time") <- frac
  cat("\n")
  print(stacktable, row.names=FALSE, right=FALSE, digits=3)
  cat("\n")
  cat(paste(files, collapse="\n"))
  cat("\n")
  cat(paste("\nParent Call:", parent.call))
  cat(paste("\n\nTotal Time:", total.time, "seconds\n"))
  cat(paste0("Percent of run time represented: ", format(frac, digits=3)), "%")
  
  invisible(stacktable)
}

Rprof("profile1.out", line.profiling=TRUE)
gc()

# User input
init.year <- 2011

n <- 100000  # Define the sample size

yearstoproject <- 5  # NEED TO force >=1 and up to 50

numberofiterations <- 1

ageL <- 30  # Define lower age limit to diseases-model simulation (min = 30)

ageH <- 84  # Define lower age limit to diseases-model simulation (max = 84)

alignment <- F # T or F (apply correction factor to counterpoise levin's and exposure error)

Fertility.Assumption <- "N"  # Select (N)ormal, (H)igh or (L)ow fertility rate asumptions based on ONS scenarios. They do matter for accurate population statistics

cvd.lag <- 5 # Avoid 0
fatality.annual.improvement.chd <- 3 # 3 means 3% annual improvement in fatality
fatality.annual.improvement.stroke <- 3 # 3 means 3% annual improvement in fatality

fatality.sec.gradient.chd <-40 # Percentage of difference in fatality between qimd 1 and 5. Positive values mean the poorest are experincing higher fatality 
fatality.sec.gradient.stroke <-40 # Percentage of difference in fatality between qimd 1 and 5. Positive values mean the poorest are experincing higher fatality 

cancer.lag <- 10 # Needs to be longer than cvd.lag to work properly (smoking histories)

clusternumber <- 1 # Change to your number of CPU cores 

cleardirectories <- F # If T delete auxiliary output directories when simulation finish

diseasestoexclude <- c("CHD", "stroke")  # Define disease to be excluded from lifetables

# *************************************************************************************************

cat("Initialising IMPACTncd...\n\n")
options(warn = 1)

if (Sys.info()[1] == "Linux") {
  if (system("whoami", T )== "mdxasck2") {
    setwd("~/IMPACTncd/")
    clusternumber <- ifelse (clusternumber<70, 70, clusternumber)  # overwrites previous if <60
  } else {
    setwd(paste("/home/", 
                system("whoami", T), 
                "/Dropbox/PhD/Models/IMPACTncd/", 
                sep = "", 
                collapse = ""))
  }
} else {
  get.dropbox.folder <- function() {
    if (!require(RCurl)) 
      stop("You need to install RCurl package.")
    if (Sys.info()["sysname"] != "Windows") 
      stop("Currently, 'get.dropbox.folder' works for Windows and Linux only. Sorry.")
    db.file <- paste(Sys.getenv("APPDATA"), "\\Dropbox\\host.db", sep = "")
    base64coded <- readLines(db.file, warn = F)[2]
    base64(base64coded, encode = F)
  }
  setwd(paste0(get.dropbox.folder(), "/PhD/Models/IMPACTncd/"))
}

source(file = "./initialisation.R")

# Create lifetable without the disease(s) to be modelled. Lifetables were calculated using data from
# England and Wales not just England. Minimal bias since we use probabilities.
cat("Generating life table...\n\n")
source(file = "./life table engine.R")

#cl <- makeCluster(clusternumber) 
registerDoParallel(clusternumber)

cat("Monte Carlo simulation...\n\n")
time.mark("start parallelisation")
foreach(iterations = 1 : it,
        .inorder = F,
        .verbose = T,
        .packages = c("data.table",
                      "dplyr",
                      "randtoolbox", 
                      "truncnorm", 
                      "stringr",
                      "compiler"),
        .export = ls(),
        .noexport = c("scenarios.list", "time.mark")) %dorng% {
          
          my.env <- environment() # get environment of this branch
          
          # Define functions in foreach loop
          sys.source(file = "./cluster functions.R", my.env)
          
          # Load synthetic population
          sys.source(file = "./load synthetic population.R", my.env)
          
          # Generating Incidence tables
          sys.source(file = "./cancer statistics.R", my.env) # for cancer
          sys.source(file = "./CVD statistics.R", my.env) # for cvd
          
          # Actual simulation
          sys.source(file = "./simulation.R", my.env)
          rm(my.env)
        }

stopCluster(cl)
Rprof(NULL)

#summaryRprof("profile1.out", lines = "show")
proftable("profile1.out", lines = 3)

